// Generated by CoffeeScript 1.7.1

/*
          >>>
          >>>                        >>>                         >>>
     >>>>>>>>   >>>>>>>    >>>>>>>   >>>>>   >>>>>>>    >>>>>>   >>>>>
    >>>   >>>  >>>   >>>  >>>   >>>  >>>    >>>   >>>  >>>       >>>
    >>>   >>>  >>>   >>>  >>>        >>>    >>>>>>>>>  >>>>>>>>  >>>
    >>>   >>>  >>>   >>>  >>>   >>>  >>>    >>>             >>>  >>>
     >>>>>>>>   >>>>>>>    >>>>>>>    >>>>   >>>>>>>    >>>>>>    >>>>
    .....................x.......xx.x.................................
 */

(function() {
  var CoffeeScript, commonjsEval, defineFunctionString, doctest, escodegen, esprima, fetch, fs, functionEval, log, noop, pathlib, repr, rewrite, run, validators, _,
    __slice = [].slice;

  doctest = function(path, options, callback) {
    var type;
    if (options == null) {
      options = {};
    }
    if (callback == null) {
      callback = noop;
    }
    _.each(_.keys(validators).sort(), function(key) {
      if (!validators[key](options[key])) {
        throw new Error("Invalid " + key + " `" + options[key] + "'");
      }
    });
    type = options.type || (function() {
      var match;
      match = /[.](coffee|js)$/.exec(path);
      if (match === null) {
        throw new Error('Cannot infer type from extension');
      }
      return match[1];
    })();
    return fetch(path, options, function(text) {
      var results, source;
      source = rewrite[type](text.replace(/^#!.*/, ''));
      results = (function() {
        switch (options.module) {
          case 'amd':
            return functionEval("" + source + ";\n" + defineFunctionString);
          case 'commonjs':
            return commonjsEval(source, path);
          default:
            return functionEval(source);
        }
      })();
      if (!options.silent) {
        log(results);
      }
      callback(results);
      return results;
    });
  };

  doctest.version = '0.6.0';

  if (typeof window !== 'undefined') {
    _ = window._, CoffeeScript = window.CoffeeScript, escodegen = window.escodegen, esprima = window.esprima;
    window.doctest = doctest;
  } else {
    fs = require('fs');
    pathlib = require('path');
    _ = require('underscore');
    CoffeeScript = require('coffee-script');
    escodegen = require('escodegen');
    esprima = require('esprima');
    module.exports = doctest;
  }

  validators = {
    module: _.partial(_.contains, [void 0, 'amd', 'commonjs']),
    silent: _.constant(true),
    type: _.partial(_.contains, [void 0, 'coffee', 'js'])
  };

  fetch = function(path, options, callback) {
    var wrapper;
    wrapper = function(text) {
      var name;
      name = _.last(path.split('/'));
      if (!options.silent) {
        console.log("running doctests in " + name + "...");
      }
      return callback(text);
    };
    if (!options.silent) {
      console.log("retrieving " + path + "...");
    }
    if (typeof window !== 'undefined') {
      return jQuery.ajax(path, {
        dataType: 'text',
        success: wrapper
      });
    } else {
      return wrapper(fs.readFileSync(path, 'utf8'));
    }
  };

  rewrite = function(input, type) {
    return rewrite[type](input.replace(/\r\n?/g, '\n'));
  };

  rewrite.js = function(input) {
    var INPUT, LINES, comments, f, processComment, xxx, zzz;
    f = function(expr) {
      return "function() {\n  return " + expr + "\n}";
    };
    processComment = (function(expr) {
      return function(comment) {
        var line, lines, match, _i, _len, _ref;
        lines = [];
        _ref = comment.value.split('\n');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          if (match = /^[ \t]*>(.*)/.exec(line)) {
            if (expr) {
              lines.push("__doctest.input(" + (f(expr)) + ")");
            }
            expr = match[1];
          } else if (match = /^[ \t]*[.]+(.*)/.exec(line)) {
            expr += "\n" + match[1];
          } else if (expr) {
            lines.push("__doctest.input(" + (f(expr)) + ")");
            lines.push("__doctest.output(" + comment.loc.start.line + ", " + (f(line)) + ")");
            expr = '';
          }
        }
        return escodegen.generate(esprima.parse(lines.join('\n')), {
          indent: '  '
        });
      };
    })('');
    zzz = function(lines, start, end, printStuff) {
      var chars, chr, column, idx, line, lineNumber, retval, state, _i, _j, _len, _len1, _ref;
      state = 0;
      chars = [];
      for (idx = _i = 0, _len = lines.length; _i < _len; idx = ++_i) {
        line = lines[idx];
        lineNumber = idx + 1;
        _ref = __slice.call(line.split('')).concat(['']);
        for (column = _j = 0, _len1 = _ref.length; _j < _len1; column = ++_j) {
          chr = _ref[column];
          if (state === 0) {
            if (lineNumber === start.line && column === start.column) {
              state = 1;
            }
          }
          if (state === 1) {
            if (lineNumber === end.line && column === end.column) {
              state = 2;
            } else {
              chars.push(chr);
            }
          }
        }
        if (state === 1) {
          chars.push('\n');
        }
      }
      retval = chars.join('');
      return retval;
    };
    INPUT = "" + input + "\n// EOF\n";
    LINES = INPUT.split('\n');
    comments = esprima.parse(INPUT, {
      comment: true,
      loc: true
    }).comments;
    return xxx = _.chain(comments).reduce(function(_arg, comment) {
      var chunks, position;
      chunks = _arg[0], position = _arg[1];
      return [__slice.call(chunks).concat([zzz(LINES, position, comment.loc.start)]), comment.loc.end];
    }, [
      [], {
        line: 1,
        column: 0
      }
    ]).first().zip(_.map(_.initial(comments), processComment)).flatten().value().join('');
  };

  rewrite.coffee = function(input) {
    var comment, expr, f, idx, indent, line, lines, match, _i, _j, _len, _ref;
    f = function(indent, expr) {
      return "->\n" + indent + "  " + expr + "\n" + indent;
    };
    lines = [];
    expr = '';
    _ref = input.split('\n');
    for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
      line = _ref[idx];
      if (match = /^([ \t]*)#(?!##)[ \t]*(.+)/.exec(line)) {
        _j = match.length - 2, indent = match[_j++], comment = match[_j++];
        if (match = /^>(.*)/.exec(comment)) {
          if (expr) {
            lines.push("" + indent + "__doctest.input " + (f(indent, expr)));
          }
          expr = match[1];
        } else if (match = /^[.]+(.*)/.exec(comment)) {
          expr += "\n" + indent + "  " + match[1];
        } else if (expr) {
          lines.push("" + indent + "__doctest.input " + (f(indent, expr)));
          lines.push("" + indent + "__doctest.output " + (idx + 1) + ", " + (f(indent, comment)));
          expr = '';
        }
      } else {
        lines.push(line);
      }
    }
    return CoffeeScript.compile(lines.join('\n'));
  };

  defineFunctionString = 'function define() {\n  var arg, idx;\n  for (idx = 0; idx < arguments.length; idx += 1) {\n    arg = arguments[idx];\n    if (typeof arg === \'function\') {\n      arg();\n      break;\n    }\n  }\n}';

  functionEval = function(source) {
    var evaluate, queue;
    evaluate = Function('__doctest', source);
    queue = [];
    evaluate({
      input: function(fn) {
        return queue.push([fn]);
      },
      output: function(num, fn) {
        return queue.push([fn, num]);
      }
    });
    return run(queue);
  };

  commonjsEval = function(source, path) {
    var abspath, queue;
    abspath = pathlib.resolve(path).replace(/[.][^.]+$/, "-" + (_.now()) + ".js");
    fs.writeFileSync(abspath, "var __doctest = {\n  queue: [],\n  input: function(fn) {\n    __doctest.queue.push([fn]);\n  },\n  output: function(num, fn) {\n    __doctest.queue.push([fn, num]);\n  }\n};\n" + source + "\n(module.exports || exports).__doctest = __doctest;");
    try {
      queue = require(abspath).__doctest.queue;
    } finally {
      fs.unlinkSync(abspath);
    }
    return run(queue);
  };

  run = function(queue) {
    var actual, arr, error, expected, input, results, _i, _len;
    results = [];
    input = noop;
    for (_i = 0, _len = queue.length; _i < _len; _i++) {
      arr = queue[_i];
      switch (arr.length) {
        case 1:
          input();
          input = arr[0];
          break;
        case 2:
          actual = (function() {
            try {
              return input();
            } catch (_error) {
              error = _error;
              return error.constructor;
            }
          })();
          expected = arr[0]();
          results.push([_.isEqual(actual, expected), repr(expected), repr(actual), arr[1]]);
          input = noop;
      }
    }
    return results;
  };

  log = function(results) {
    var actual, expected, num, pass, _i, _len, _ref;
    console.log(((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        pass = results[_i][0];
        _results.push(pass ? '.' : 'x');
      }
      return _results;
    })()).join(''));
    for (_i = 0, _len = results.length; _i < _len; _i++) {
      _ref = results[_i], pass = _ref[0], expected = _ref[1], actual = _ref[2], num = _ref[3];
      if (!pass) {
        console.log("FAIL: expected " + expected + " on line " + num + " (got " + actual + ")");
      }
    }
  };

  noop = function() {};

  repr = function(val) {
    switch (Object.prototype.toString.call(val)) {
      case '[object String]':
        return '"' + val.replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
      case '[object Function]':
        return val.name;
      default:
        return val;
    }
  };

}).call(this);
